<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Office Dashboard</title>
  <link rel="stylesheet" href="./winbox.min.css">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
<script src="./winbox.bundle.min.js"></script>
<script>
  /**
   * We'll replace the blank src with "about:blank" when minimizing the window.
   * Then, on restore, we move back to the stored position and size, and restore the original iframe url.
   */

  let pageState = {
    columns: 40,
    rows: 32,
    windows: []
  };

  const winMap = {};

  function getCellSizes() {
    const { columns, rows } = pageState;
    const w = window.innerWidth;
    const h = window.innerHeight;
    return {
      cellWidth: w / columns,
      cellHeight: h / rows
    };
  }

  function updateGrid() {
    const { columns, rows } = pageState;
    const w = window.innerWidth;
    const h = window.innerHeight;
    const cellWidth = w / columns;
    const cellHeight = h / rows;

    document.body.style.backgroundImage = `
      linear-gradient(to right, rgba(0,0,0,0.15) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(0,0,0,0.15) 1px, transparent 1px)
    `;
    document.body.style.backgroundSize = `${cellWidth}px ${cellHeight}px`;
    document.body.style.backgroundPosition = "0 0";

    console.log(`Grid updated => cellWidth=${cellWidth.toFixed(2)}, cellHeight=${cellHeight.toFixed(2)}`);
  }

  function snapDimension(width, height, cellWidth, cellHeight) {
    const snappedW = Math.round(width / cellWidth) * cellWidth;
    const snappedH = Math.round(height / cellHeight) * cellHeight;
    return { snappedW, snappedH };
  }

  function snapPosition(left, top, width, height, cellWidth, cellHeight) {
    const right = left + width;
    const bottom = top + height;

    // X axis
    const nearestLeft = Math.round(left / cellWidth) * cellWidth;
    const nearestRight = Math.round(right / cellWidth) * cellWidth;
    const distLeft = Math.abs(left - nearestLeft);
    const distRight = Math.abs(right - nearestRight);
    const snappedX = distLeft <= distRight ? nearestLeft : nearestRight - width;

    // Y axis
    const nearestTop = Math.round(top / cellHeight) * cellHeight;
    const nearestBottom = Math.round(bottom / cellHeight) * cellHeight;
    const distTop = Math.abs(top - nearestTop);
    const distBottom = Math.abs(bottom - nearestBottom);
    const snappedY = distTop <= distBottom ? nearestTop : nearestBottom - height;

    return { snappedX, snappedY };
  }

  function updateQueryParameters() {
    const params = new URLSearchParams(window.location.search);
    params.set("pageState", JSON.stringify(pageState));
    const newUrl = window.location.pathname + "?" + params.toString();
    window.history.replaceState(null, "", newUrl);
  }

  function generateId() {
    return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
  }

  function updateWindowState(win, newProps) {
    const stateObj = pageState.windows.find(s => s.id === win._stateId);
    if (!stateObj) return;

    Object.assign(stateObj, newProps);

    if ("x" in newProps || "y" in newProps || "width" in newProps || "height" in newProps) {
      const { x, y, width, height } = stateObj;
      const { cellWidth, cellHeight } = getCellSizes();
      stateObj.gridX = x / cellWidth;
      stateObj.gridY = y / cellHeight;
      stateObj.gridWidth = width / cellWidth;
      stateObj.gridHeight = height / cellHeight;
    }
    updateQueryParameters();
  }

  function removeWindowState(id) {
    pageState.windows = pageState.windows.filter(s => s.id !== id);
    updateQueryParameters();
  }

  function createSnappingWindow(state) {
    console.log("Creating window => ", state);

    let myContainer = null;
    let positionTimer = null;
    let resizeTimer = null;
    let isSnappingPosition = false;
    let isSnappingDimension = false;
    const DEBOUNCE_MS = 200;

    // Provide some defaults
    if (typeof state._origWidth === "undefined") {
      state._origWidth = state.width || 400;
    }
    if (typeof state._origHeight === "undefined") {
      state._origHeight = state.height || 300;
    }
    if (typeof state.isMinimized === "undefined") {
      state.isMinimized = false;
    }
    if (typeof state.isMaximized === "undefined") {
      state.isMaximized = false;
    }

    const win = new WinBox({
      title: state.url,
      url: state.url,
      x: state.x,
      y: state.y,
      width: state.width || 400,
      height: state.height || 300,
      background: "#000C66",

      onmove: () => {
        clearTimeout(positionTimer);
        positionTimer = setTimeout(() => {
          if (!myContainer || isSnappingPosition) return;
          const rect = myContainer.getBoundingClientRect();
          const { cellWidth, cellHeight } = getCellSizes();
          const { snappedX, snappedY } = snapPosition(
            rect.left,
            rect.top,
            rect.width,
            rect.height,
            cellWidth,
            cellHeight
          );

          if (Math.abs(rect.left - snappedX) > 1 || Math.abs(rect.top - snappedY) > 1) {
            isSnappingPosition = true;
            console.log(`Snapping position from (${rect.left}, ${rect.top}) to (${snappedX}, ${snappedY})`);
            win.move(snappedX, snappedY);
            updateWindowState(win, { x: snappedX, y: snappedY });
            setTimeout(() => isSnappingPosition = false, DEBOUNCE_MS);
          } else {
            updateWindowState(win, { x: rect.left, y: rect.top });
          }
        }, DEBOUNCE_MS);
      },
      onresize: (width, height) => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          if (!myContainer || isSnappingDimension) return;
          // If the window is nearly fullscreen, skip snapping
          if (width >= window.innerWidth - 10 && height >= window.innerHeight - 10) {
            console.log("Window nearly full screen => skip dimension snap");
            updateWindowState(win, { width, height });
            return;
          }

          const rect = myContainer.getBoundingClientRect();
          const { cellWidth, cellHeight } = getCellSizes();
          const { snappedW, snappedH } = snapDimension(rect.width, rect.height, cellWidth, cellHeight);

          if (Math.abs(rect.width - snappedW) > 1 || Math.abs(rect.height - snappedH) > 1) {
            isSnappingDimension = true;
            console.log(`Snapping dimension from (${rect.width}x${rect.height}) to (${snappedW}x${snappedH})`);
            win.resize(snappedW, snappedH);
            updateWindowState(win, { width: snappedW, height: snappedH });
            setTimeout(() => isSnappingDimension = false, DEBOUNCE_MS);
          } else {
            updateWindowState(win, { width: rect.width, height: rect.height });
          }
        }, DEBOUNCE_MS);
      },

      onclose: () => {
        console.log(`Window closed => ${state.url}`);
        removeWindowState(win._stateId);
      },

      onminimize: () => {
        if (!myContainer) return;
        console.log("Initial DOM at minimize =>", myContainer.outerHTML);

        // Capture current dimensions and position for restore
        const rect = myContainer.getBoundingClientRect();
        state._savedWidthBeforeMinimize = rect.width;
        state._savedHeightBeforeMinimize = rect.height;
        state._savedXBeforeMinimize = rect.left;
        state._savedYBeforeMinimize = rect.top;

        state.isMinimized = true;
        state.isMaximized = false;
        updateWindowState(win, { isMinimized: true, isMaximized: false });

        const iframe = myContainer.querySelector(".wb-body iframe");
        if (iframe) {
          const oldSrc = iframe.src;
          if (!state._savedUrl) {
            state._savedUrl = oldSrc;
          }
          // Use about:blank for the blank iframe
          iframe.src = "about:blank";
          console.log(`Changed iframe src from '${oldSrc}' to '${iframe.src}'`);
          console.log("After clearing iframe =>", myContainer.outerHTML);
        } else {
          console.log("No iframe found in the window to clear.");
        }
      },

      onmaximize: () => {
        if (!myContainer) return;
        console.log("Initial DOM at maximize =>", myContainer.outerHTML);

        state.isMinimized = false;
        state.isMaximized = true;
        updateWindowState(win, { isMinimized: false, isMaximized: true });

        const iframe = myContainer.querySelector(".wb-body iframe");
        if (iframe && state._savedUrl) {
          const oldSrc = iframe.src;
          iframe.src = state._savedUrl;
          console.log(`Changed iframe src from '${oldSrc}' to '${iframe.src}'`);
        }

        console.log("After restoring iframe =>", myContainer.outerHTML);
      },

      onrestore: () => {
        if (!myContainer) return;
        console.log("Window restored =>", myContainer.outerHTML);

        state.isMinimized = false;
        state.isMaximized = false;
        updateWindowState(win, { isMinimized: false, isMaximized: false });

        // If we stored dimensions and position before minimize, restore them
        if (typeof state._savedWidthBeforeMinimize !== 'undefined'
          && typeof state._savedHeightBeforeMinimize !== 'undefined'
          && typeof state._savedXBeforeMinimize !== 'undefined'
          && typeof state._savedYBeforeMinimize !== 'undefined') {
          win.move(state._savedXBeforeMinimize, state._savedYBeforeMinimize);
          win.resize(state._savedWidthBeforeMinimize, state._savedHeightBeforeMinimize);
          updateWindowState(win, {
            x: state._savedXBeforeMinimize,
            y: state._savedYBeforeMinimize,
            width: state._savedWidthBeforeMinimize,
            height: state._savedHeightBeforeMinimize
          });
        }

        const iframe = myContainer.querySelector(".wb-body iframe");
        if (iframe && state._savedUrl) {
          const oldSrc = iframe.src;
          iframe.src = state._savedUrl;
          console.log(`Restored iframe src from '${oldSrc}' to '${iframe.src}'`);
          console.log("After restoring iframe =>", myContainer.outerHTML);
        }
      }
    });

    // Slight delay to find the .winbox container
    setTimeout(() => {
      const allBoxes = document.querySelectorAll('.winbox');
      const myIndex = allBoxes.length - 1;
      myContainer = allBoxes[myIndex];
      console.log("myContainer found =>", myContainer);

      // Right-click on maximize => restore default size
      const maxButton = myContainer.querySelector(".wb-max");
      if (maxButton) {
        maxButton.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          console.log("Right-click on maximize => restore default size");
          win.resize(state._origWidth, state._origHeight);
          updateWindowState(win, { width: state._origWidth, height: state._origHeight });
        });
      }

      // If the window was minimized or maximized, replicate that now
      if (state.isMinimized) {
        win.minimize();
      } else if (state.isMaximized) {
        win.maximize();
      } else {
        // If there's a saved iframe url from earlier, restore it
        const iframe = myContainer.querySelector(".wb-body iframe");
        if (iframe && state._savedUrl) {
          iframe.src = state._savedUrl;
        }
      }
    }, 100);

    // Link the WinBox to the state's ID
    win._stateId = state.id;
    winMap[state.id] = win;

    // If we have no grid coords, store them
    if (typeof state.gridX === "undefined") {
      const { cellWidth, cellHeight } = getCellSizes();
      state.gridX = state.x / cellWidth;
      state.gridY = state.y / cellHeight;
      state.gridWidth = state.width / cellWidth;
      state.gridHeight = state.height / cellHeight;
    }

    return win;
  }

  function initializePage() {
    const params = new URLSearchParams(window.location.search);
    const pageStateParam = params.get("pageState");
    if (pageStateParam) {
      try {
        pageState = JSON.parse(pageStateParam);
      } catch (e) {
        console.error("Error parsing pageState:", e);
      }
    }
    updateGrid();
    pageState.windows.forEach(s => createSnappingWindow(s));
  }

  function repositionWindows() {
    const { windows } = pageState;
    const { cellWidth, cellHeight } = getCellSizes();

    windows.forEach(state => {
      const win = winMap[state.id];
      if (!win) return;

      const newX = state.gridX * cellWidth;
      const newY = state.gridY * cellHeight;
      const newW = state.gridWidth * cellWidth;
      const newH = state.gridHeight * cellHeight;

      win.move(newX, newY);
      win.resize(newW, newH);

      state.x = newX;
      state.y = newY;
      state.width = newW;
      state.height = newH;
    });
    updateQueryParameters();
  }

  document.addEventListener("contextmenu", e => {
    if (e.target === document.body || e.target === document.documentElement) {
      e.preventDefault();
      const urlInput = prompt("Enter URL:");
      if (urlInput) {
        let url = urlInput.trim();
        if (!/^https?:\/\//i.test(url)) {
          url = "http://" + url;
        }
        const newX = 10 + (pageState.windows.length * 20);
        const newY = 10 + (pageState.windows.length * 20);

        const newWinState = {
          id: generateId(),
          url,
          x: newX,
          y: newY,
          width: 400,
          height: 300,
          isMinimized: false,
          isMaximized: false,
          _savedUrl: ""
        };

        pageState.windows.push(newWinState);
        updateQueryParameters();
        createSnappingWindow(newWinState);
      }
    }
  });

  window.addEventListener("load", initializePage);
  window.addEventListener("resize", () => {
    updateGrid();
    repositionWindows();
  });
</script>
</body>
</html>
